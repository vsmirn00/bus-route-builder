from app.http_model.response import MapResponse, RouteResponse
from app.model.handler import ModelHandler
import folium # type: ignore
from loguru import logger
from typing import List

RANDOM_STATE = 42

class ModelAdapter(ModelHandler):
    """
    Adapter class for handling model predictions and merging Folium maps.
    """
    
    def __init__(self):
        """
        Initializes the ModelAdapter class.
        """
        logger.info("Initializing ModelAdapter")
        try:
            self.model_handler = ModelHandler()
            self.random_state = 42
            logger.info("ModelAdapter initialized successfully")
        except Exception as e:
            logger.error(f"Error initializing ModelAdapter: {e}")
            raise
    
    def merge_folium_maps(self, maps: List[folium.Map]) -> folium.Map:
        """
        Merges multiple Folium maps into a single map.

        Parameters
        ----------
        maps : List[folium.Map]
            List of Folium map objects to merge.

        Returns
        -------
        folium.Map
            A single merged Folium map containing layers from all input maps.
        """
        logger.info("Merging Folium maps")
        try:
            base_map = folium.Map(location=maps[0].location, zoom_start=15, tiles="cartodbpositron")
            
            for map_obj in maps:
                for child in map_obj._children.values():
                    base_map.add_child(child)
            
            logger.info("Successfully merged Folium maps")
            return base_map
        except Exception as e:
            logger.error(f"Error merging Folium maps: {e}")
            raise
    
    def parse_output(self, output_routes, request):
        """
        Parses the model output into a structured response format.

        Parameters
        ----------
        output_routes : list
            List of optimized routes generated by the model.
        request : object
            The request object containing input parameters.

        Returns
        -------
        dict
            A dictionary containing the parsed output including route details and metadata.
        """
        logger.info("Parsing output routes")
        try:
            res = [MapResponse.model_validate({"route_id": idx, "route_num_stations": len(output_routes[idx][0]), "distance": output_routes[idx][-1]}) for idx in range(len(output_routes))]
            
            num_stations = sum([len(output_routes[idx][0]) for idx in range(len(output_routes))]) + int(request.central_station) - (int(request.central_station) * len(output_routes))

            parsed_output = RouteResponse.model_validate({
                "name": request.name,
                "input_path": request.input_path,
                "output_path": request.output_path,
                "num_stations": num_stations,
                "num_routes": self.model_handler.num_routes,
                "central_station": request.central_station,
                "balanced_num_stops": request.balance_stations,
                "results": res
            })
            logger.info("Successfully parsed output routes")
            return parsed_output
        except Exception as e:
            logger.error(f"Error parsing output: {e}")
            raise

    def predict(self, request, method="ward"):
        """
        Runs the prediction pipeline and returns optimized routes along with a merged Folium map.

        Parameters
        ----------
        request : object
            The request object containing input data for prediction.
        method : str, optional
            The clustering method to use for route optimization (default is "ward").

        Returns
        -------
        tuple
            - dict: Parsed output containing optimized routes and metadata.
            - folium.Map: A merged Folium map displaying the optimized routes.
        """
        logger.info("Starting prediction process")
        try:
            routes, maps = self.model_handler.predict(request, method=method)
            logger.info("Finished route optimization")
            
            final_map = self.merge_folium_maps(maps)
            logger.info("Generated final merged map")
            
            parsed_output = self.parse_output(routes, request)
            logger.info("Prediction process completed successfully")
            
            return parsed_output, final_map
        except Exception as e:
            logger.error(f"Error during prediction process: {e}")
            raise